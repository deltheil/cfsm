#!/usr/bin/env python

# Copyright 2007 Damien Miller <djm@mindrot.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# I assert no rights over the output of the cfsm program (i.e. the
# generated C source file, header and dot graph). If you find cfsm
# useful and use it in your project, then a credit notice in the source
# or documentation would be appreciated, but is not required.

import re
import sys
import getopt

def usage():
	print """
cfsm.py -- Finite state machine compiler
Usage: cfsm.py [-h] [-C source.c] [-H header.h] [-D dotfile.dot] input.fsm

Command-line flags:
        -h             Display this help
        -C path        Output C source to "path"
        -H path        Output C header to "path"
        -D path        Output graphviz dot graph to "path"
"""

def main():
	try:
		opts, args = getopt.getopt(sys.argv[1:], 'C:D:H:h')
	except getopt.GetoptError:
		print >> sys.stderr, "Error: Invalid commandline arguments"
		usage()
		sys.exit(1)

	source_file = None
	header_file = None
	dot_file = None
	for o, a in opts:
		if o in ('-h', '--help'):
			usage()
			sys.exit(0)
		if o in ('-C', '--source'):
			source_file = a
		if o in ('-D', '--dot'):
			dot_file = a
		if o in ('-H', '--heder'):
			header_file = a
	if len(args) != 1:
		print >> sys.stderr, "Error: No input file specified"
		usage()
		sys.exit(1)

	input_path = args[0]

	if source_file is None and header_file is None and dot_file is None:
		print >> sys.stderr, "Error: No output file(s) specified"
		usage()
		sys.exit(1)

	keywords = {
		'state'				: [ False, 2 ],
		'next-state'			: [ True, 2 ],
		'entry-precondition'		: [ True, 2 ],
		'onentry-func'			: [ True, 2 ],
		'exit-precondition'		: [ True, 2 ],
		'onexit-func'			: [ True, 2 ],
		'initial-state'			: [ True, 1 ],
		'fsm-struct-type'		: [ False, 2 ],
		'state-enum-type'		: [ False, 2 ],
		'advance-function'		: [ False, 2 ],
		'free-function'			: [ False, 2 ],
		'initialise-function'		: [ False, 2 ],
		'initialize-function'		: [ False, 2 ],
		'current-state-function'	: [ False, 2 ],
		'enum-to-string-function'	: [ False, 2 ],
		'source-banner'			: [ False, 1 ],
	}

	lnum = 0
	fsm = FSM()
	state = None
	banner = None
	input_file = open(input_path)
	for line in input_file:
		lnum += 1
		comment_ndx = line.find('#')
		if comment_ndx != -1:
			line = line[:comment_ndx]
		line = line.strip()
		if line == "":
			continue

		terms = line.split()
		if not terms[0] in keywords:
			print >> sys.stderr, "line %d:" % lnum, \
			    "unsupported directive \"%s\"" % terms[0]
			sys.exit(1)
		if len(terms) != keywords[terms[0]][1]:
			print >> sys.stderr, "line %d:" % lnum, \
			    "syntax error"
			sys.exit(1)
		if keywords[terms[0]][0] and state is None:
			print >> sys.stderr, "line %d:" % lnum, \
			    terms[0], "cannot be used outside of", \
			    "a state definition"
			sys.exit(1)

		try:
			if terms[0] == 'state':
				if state is not None:
					fsm.add_state(state)
				state = State(terms[1])
			elif terms[0] == 'next-state':
				state.add_next_state(terms[1])
				# XXX support:
				# next-state FOO transition_func
			elif terms[0] == 'entry-precondition':
				state.add_pre_entry_func(terms[1])
			elif terms[0] == 'onentry-func':
				state.add_post_entry_func(terms[1])
			elif terms[0] == 'exit-precondition':
				state.add_pre_exit_func(terms[1])
			elif terms[0] == 'onexit-func':
				state.add_post_exit_func(terms[1])
			elif terms[0] == 'initial-state':
				state.initial = True
			elif terms[0] == 'fsm-struct-type':
				fsm.struct_name = terms[1]
			elif terms[0] == 'state-enum-type':
				fsm.enum_name = terms[1]
			elif terms[0] == 'initialise-function' or \
			     terms[0] == 'initialize-function':
				fsm.init_func = terms[1]
			elif terms[0] == 'free-function':
				fsm.free_func = terms[1]
			elif terms[0] == 'advance-function':
				fsm.advance_func = terms[1]
			elif terms[0] == 'current-state-function':
				fsm.cuttent_state_func = terms[1]
			elif terms[0] == 'enum-to-string-function':
				fsm.enum_to_string_func = terms[1]
			elif terms[0] == 'source-banner':
				source_banner = ""
				for l in input_file:
					lnum += 1
					if l.startswith('end-source-banner'):
						break
					source_banner += l
				if not l.startswith('end-source-banner'):
					raise ValueError, \
					   "EOF looking for end-source-banner"
				fsm.source_banner = source_banner

		except ValueError, e:
				print >> sys.stderr, "line %d:" % lnum, e
				sys.exit(1)

	if state is not None:
		fsm.add_state(state)

	try:
		fsm.finalise()
	except ValueError, e:
		print >> sys.stderr, e
		sys.exit(1)

	if header_file is not None:
		fsm.output_header(open(header_file, "w"), header_file)
	if source_file is not None:
		fsm.output_source(open(source_file, "w"), header_file)
	if dot_file is not None:
		fsm.output_dot(open(dot_file, "w"))

class FSM:
	def __init__(self):
		self.state_list = []
		self.states = {}
		self.enum_name = "state"
		self.struct_name = "fsm"
		self.free_func = "state_free"
		self.init_func = "state_init"
		self.advance_func = "state_advance"
		self.enum_to_string_func = "state_ntop"
		self.current_state_func = "state_current"
		self.source_banner = None

	def add_state(self, state):
		if state.name in self.states:
			raise ValueError, "State %s already added" % state.name
		self.state_list.append(state)
		self.states[state.name] = state

	def finalise(self):
		indegrees = dict([ (s, 0) for s in self.states])
		for state in self.states:
			for arc in self.states[state].next_states:
				if not arc in self.states:
					raise ValueError, "State " + state + \
					    " refers to nonexistent " + \
					    "next-state " + arc
				indegrees[arc] += 1
		for state in indegrees:
			if indegrees[state] == 0 and \
			   not self.states[state].initial:
				raise ValueError, "Unreachable state " + state
			
	def output_header(self, h, filename):
		guard = filename.upper().replace('/', '__').replace('.', '_')
		banner = ""
		if self.source_banner is not None:
			banner = banner + "\n"

		enum_contents = ""
		i = 0
		for state in self.state_list:
			enum_contents += "	%s = %u,\n" % (state.name, i)
			i += 1
		init_states = [s.name for s in self.state_list if s.initial]
		if len(init_states) > 1:
			init_func_proto_comments = _INIT_FUNC_MULTI
		else:
			init_func_proto_comments = _INIT_FUNC_SINGLE

 		init_func_proto_comments %= {
			    "struct_name" : self.struct_name,
			    "init_func" : self.init_func,
			    "enum_name" : self.enum_name,
			    "init_state" : init_states[0],
			}
		
		print >> h, _C_HEADER % {
		    "init_func_proto_comments" : init_func_proto_comments,
		    "enum_contents" : enum_contents,
		    "self_promotion" : _SELF_PROMOTION,
		    "banner" : banner,
		    "guard" : guard,
		    "struct_name" : self.struct_name,
		    "enum_name" : self.enum_name,
		    "init_func" : self.init_func,
		    "free_func" : self.free_func,
		    "advance_func" : self.advance_func,
		    "enum_to_string_func" : self.enum_to_string_func,
		    "current_state_func" : self.current_state_func
		}

	def _build_state_func_prototypes(self):
		actions = {}
		preconds = {}
		for state in self.state_list:
			for func in state.pre_entry_funcs:
				preconds[func] = True
			for func in state.pre_exit_funcs:
				preconds[func] = True
			for func in state.post_entry_funcs:
				actions[func] = True
			for func in state.post_exit_funcs:
				actions[func] = True
		ret = ""
		if len(actions) > 0:
			ret += _TRANS_FUNC_COMMENT
		for func in actions:
			ret += _TRANS_FUNC_PROTO % {
			    "func" : func,
			    "enum_name" : self.enum_name
			}

		if len(preconds) > 0:
			ret += _PRECOND_FUNC_COMMENT
		for func in preconds:
			ret += _PRECOND_FUNC_PROTO % {
			    "func" : func,
			    "enum_name" : self.enum_name
			}
		return ret

	def _build_transition_checks(self):
		# XXX this might be better done using an adjacency matrix
		#     (perhaps packed into a bit vector for space)
		# Output transition validity checking
		ret = ""
		for state in self.state_list:
			ret += "	case %s:\n" % state.name
			if len(state.next_states) == 0:
				ret += "		goto bad_transition;\n"
				continue
			ret += "		switch (new_state) {\n"
			for arc in state.next_states:
				ret += "		case %s:\n" % arc
			ret += \
"""			break;
		default:
			goto bad_transition;
		}
		break;
"""
		return ret

	def _build_state_calls(self, what, which, attr, critical):
		# Output state change precondition/entry/exit calls
		# This could be folded into the transition checking switch,
		# but the code would be IMHO less readable
		if which == "entry":
			var = "new_state"
		elif which == "exit":
			var = "fsm->current_state"
		else:
			raise ValueError, "bogus which \"%s\"" % which

		switch_started = False
		ret = ""
		for state in self.state_list:
			funcs = getattr(state, attr)
			if len(funcs) == 0:
				continue
			if not switch_started:
				ret += _STATE_CALL_SWITCH_START % {
				    "which" : which,
				    "what" : what,
				    "var" : var,
				}
				switch_started = True
			ret += _STATE_CALL_SWITCH_CASE % { 
			    "state" : state.name
			}
			for func in funcs:
				if critical:
					frag = _PRECONDITION_FUNC_CALL
				else:
					frag = _TRANSITION_FUNC_CALL
				ret += frag % {
				    "which" : which,
				    "func" : func
				}
			ret += "		break;\n"
		if switch_started:
			ret += _STATE_CALL_SWITCH_FINISH
		return ret

	def output_source(self, h, header_path):
		banner = ""
		if self.source_banner is not None:
			banner = self.source_banner + "\n"

		state_func_prototypes = self._build_state_func_prototypes()
		transition_check = self._build_transition_checks()
		exit_preconds = self._build_state_calls("preconditions",
		    "exit", "pre_exit_funcs", True)
		entry_preconds = self._build_state_calls("preconditions",
		    "entry", "pre_entry_funcs", True)
		trans_funcs = self._build_state_calls("transition functions",
		    "exit", "post_exit_funcs", False)
		trans_funcs += self._build_state_calls("transition functions",
		    "entry", "post_entry_funcs", False)

		error_handlers = ""
		if entry_preconds != "":
			error_handlers += _ENTRY_PRECOND_FAIL
		if exit_preconds != "":
			error_handlers += _EXIT_PRECOND_FAIL
		error_handlers %= {
		    "enum_to_string_func" : self.enum_to_string_func
		}

		enum_contents = ""
		for state in self.state_list:
			enum_contents += "\t\t\"%s\",\n" % state.name

		init_states = [s.name for s in self.state_list if s.initial]
		if len(init_states) > 1:
			init_func_def = _STATE_INIT_FUNC_MULTI
		else:
			init_func_def = _STATE_INIT_FUNC_SINGLE
		init_state_cases = \
		    "\n".join(["\tcase %s:" % case for case in init_states])

		init_func_def %= {
			    "init_func" : self.init_func,
			    "enum_name" : self.enum_name,
			    "struct_name" : self.struct_name,
			    "initial_state" : init_states[0],
			    "init_state_cases" : init_state_cases,
			    "enum_to_string_func" : self.enum_to_string_func,
		}

		print >> h, _C_SOURCE % {
		    "header_path" : header_path,
		    "self_promotion" : _SELF_PROMOTION,
		    "banner" : banner,
		    "struct_name" : self.struct_name,
		    "enum_name" : self.enum_name,
		    "init_func" : self.init_func,
		    "free_func" : self.free_func,
		    "advance_func" : self.advance_func,
		    "enum_to_string_func" : self.enum_to_string_func,
		    "current_state_func" : self.current_state_func,
		    "state_func_prototypes" : state_func_prototypes,
		    "min_valid" : self.state_list[0].name,
		    "max_valid" : self.state_list[-1].name,
		    "enum_contents" : enum_contents,
		    "init_func_def" : init_func_def,
		    "transition_check" : transition_check,
		    "entry_preconds" : entry_preconds,
		    "exit_preconds" : exit_preconds,
		    "trans_funcs" : trans_funcs,
		    "error_handlers" : error_handlers,
		}

	def output_dot(self, h):
		# XXX pretty basic. Doesn't show preconditions, etc.
		# XXX should be a template
		print >> h, "digraph FSM {"
		print >> h, "	rankdir = LR;"
		print >> h, "	node [shape = doublecircle];",
		for state in self.state_list:
			if not state.initial:
				continue;
			print >> h, state.name,
		print >> h, "\n	node [shape = circle];",
		for state in self.state_list:
			if state.initial:
				continue;
			print >> h, state.name,
		print >> h, ""
		for state in self.state_list:
			for arc in state.next_states:
				print >> h, "	%s -> %s;" % (state.name, arc)
		print >> h, "}"

class State:
	def __init__(self, name):
		self._name_check(name)
		self.name = name
		self.next_states = []
		self.pre_entry_funcs = []
		self.post_entry_funcs = []
		self.pre_exit_funcs = []
		self.post_exit_funcs = []
		self.initial = False
	def _name_check(self, name):
		if re.match('^[A-Za-z_][A-Za-z0-9_]*$', name) is None:
			raise ValueError, "Invalid name \"%s\"" % name
	def add_next_state(self, name):
		self._name_check(name)
		self.next_states.append(name)
	def add_pre_entry_func(self, name):
		self._name_check(name)
		self.pre_entry_funcs.append(name)
	def add_post_entry_func(self, name):
		self._name_check(name)
		self.post_entry_funcs.append(name)
	def add_pre_exit_func(self, name):
		self._name_check(name)
		self.pre_exit_funcs.append(name)
	def add_post_exit_func(self, name):
		self._name_check(name)
		self.post_exit_funcs.append(name)

# -------------------------------------------------------------------------
# The following section contains the template strings and fragments that
# are emitted into the generated C source and header files
# -------------------------------------------------------------------------

_SELF_PROMOTION = """/*
 * Automatically generated using the cfsm FSM compiler:
 * http://www.mindrot.org/projects/cfsm/
 */"""

# -------------------------------------------------------------------------

_INIT_FUNC_MULTI = """/*
 * Allocate a new FSM and set its starting state to "initial_state".
 * Will return a pointer to the opaque FSM structure on success or 
 * NULL on failure. If "errbuf" is not NULL, upto "errlen" bytes of
 * error message will be copied into "errbuf" on failure.
 */
struct %(struct_name)s *%(init_func)s(enum %(enum_name)s initial_state,
    char *errbuf, size_t errlen);"""

# -------------------------------------------------------------------------

_INIT_FUNC_SINGLE = """/*
 * Allocate a new FSM and set its starting state to %(init_state)s
 * Will return a pointer to the opaque FSM structure on success or 
 * NULL on failure. If "errbuf" is not NULL, upto "errlen" bytes of
 * error message will be copied into "errbuf" on failure.
 */
struct %(struct_name)s *%(init_func)s(char *errbuf, size_t errlen);"""

# -------------------------------------------------------------------------

_C_HEADER="""%(banner)s%(self_promotion)s

#ifndef %(guard)s
#define %(guard)s

#include <sys/types.h>

/*
 * The valid states of the FSM
 */
enum %(enum_name)s {
%(enum_contents)s};

/*
 * The FSM object itself. This is intentionally opaque - all access must be
 * through this API
 */
struct %(struct_name)s;

%(init_func_proto_comments)s

/*
 * Free a FSM created with %(init_func)s()
 */
void %(free_func)s(struct %(struct_name)s *fsm);

/*
 * Attempt to advance to the state specified by "new_state". Will return
 * 0 on success, -1 on failure. If "errbuf" is not NULL, upto "errlen"
 * bytes of error message will be copied into "errbuf" on failure.
 */
int %(advance_func)s(struct %(struct_name)s *fsm, enum %(enum_name)s new_state,
    char *errbuf, size_t errlen);

/*
 * Convert from the %(enum_name)s enumeration to a string. Will return
 * NULL if the state is not known.
 */
const char *%(enum_to_string_func)s(enum %(enum_name)s);

/*
 * "Safe" version of %(enum_to_string_func)s. Will return the string
 * "[INVALID]" if the state is not known, so it can be used directly
 * in printf() statements, etc.
 */
const char *%(enum_to_string_func)s_safe(enum %(enum_name)s);

/*
 * Returns the current state of the FSM.
 */
enum %(enum_name)s %(current_state_func)s(struct %(struct_name)s *fsm);

#endif /* %(guard)s */
"""

# -------------------------------------------------------------------------

_TRANS_FUNC_COMMENT = \
"""
/* Prototypes for transition functions */
"""
_PRECOND_FUNC_COMMENT = \
"""
/* Prototypes for precondition checks */
"""

_TRANS_FUNC_PROTO = \
"""void %(func)s(enum %(enum_name)s, enum %(enum_name)s);
"""
_PRECOND_FUNC_PROTO = \
"""int %(func)s(enum %(enum_name)s, enum %(enum_name)s);
"""

# -------------------------------------------------------------------------

_STATE_INIT_FUNC_MULTI = \
"""struct %(struct_name)s *
%(init_func)s(enum %(enum_name)s initial_state, char *errbuf, size_t errlen)
{
	struct %(struct_name)s *ret = NULL;

	switch (initial_state) {
%(init_state_cases)s
		break;
	default:
		if (errlen > 0 && errbuf != NULL) {
			snprintf(errbuf, errlen,
			    "State %%s (%%d) is not a valid start state",
			    %(enum_to_string_func)s_safe(initial_state),
			    initial_state);
		}
		return NULL;
	}
	if ((ret = calloc(1, sizeof(*ret))) == NULL) {
		if (errlen > 0 && errbuf != NULL)
			snprintf(errbuf, errlen, "Memory allocation failed");
		return NULL;
	}
	ret->current_state = initial_state;
	return ret;
}"""

# -------------------------------------------------------------------------

_STATE_INIT_FUNC_SINGLE = \
"""struct %(struct_name)s *
%(init_func)s(char *errbuf, size_t errlen)
{
	struct %(struct_name)s *ret = NULL;

	if ((ret = calloc(1, sizeof(*ret))) == NULL) {
		if (errlen > 0 && errbuf != NULL)
			snprintf(errbuf, errlen, "Memory allocation failed");
		return NULL;
	}
	ret->current_state = %(initial_state)s;
	return ret;
}"""

# -------------------------------------------------------------------------

_STATE_CALL_SWITCH_START = \
"""
	/* %(which)s %(what)s */
	switch (%(var)s) {
"""

_STATE_CALL_SWITCH_CASE = \
"""	case %(state)s:
"""

_STATE_CALL_SWITCH_FINISH = \
"""	default:
		break; /* Hush compiler warnings */
	}
"""
# -------------------------------------------------------------------------

_PRECONDITION_FUNC_CALL = \
"""		if (%(func)s(fsm->current_state, new_state) != 0)
			goto %(which)s_precond_fail;
"""
_TRANSITION_FUNC_CALL = \
"""		%(func)s(fsm->current_state, new_state);
"""

# -------------------------------------------------------------------------

_ENTRY_PRECOND_FAIL = \
""" entry_precond_fail:
	if (errlen > 0 && errbuf != NULL) {
		snprintf(errbuf, errlen,
		    "State %%s entry precondition not satisfied",
		    %(enum_to_string_func)s_safe(new_state));
	}
	return -1;
"""

_EXIT_PRECOND_FAIL = \
""" exit_precond_fail:
	if (errlen > 0 && errbuf != NULL) {
		snprintf(errbuf, errlen,
		    "State %%s exit precondition not satisfied",
		    %(enum_to_string_func)s_safe(fsm->current_state));
	}
	return -1;
"""

# -------------------------------------------------------------------------

_C_SOURCE="""%(banner)s%(self_promotion)s

#include <sys/types.h>

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "%(header_path)s"

/* Private view of opaque FSM structure */
struct %(struct_name)s {
	enum %(enum_name)s current_state;
};
%(state_func_prototypes)s
static int
_is_%(enum_name)s_valid(enum %(enum_name)s n)
{
	if (!(n >= %(min_valid)s && n <= %(max_valid)s))
		return -1;
	return 0;
}

const char *
%(enum_to_string_func)s(enum %(enum_name)s n)
{
	const char *state_names[] = {
%(enum_contents)s	};

	if (_is_%(enum_name)s_valid(n) != 0)
		return NULL;
	return state_names[n];
}

const char *
%(enum_to_string_func)s_safe(enum %(enum_name)s n)
{
	const char *r = %(enum_to_string_func)s(n);

	return r == NULL ? "[INVALID]" : r;
}

%(init_func_def)s

void
%(free_func)s(struct %(struct_name)s *fsm)
{
	memset(fsm, '\\0', sizeof(fsm));
	free(fsm);
}

enum %(enum_name)s
%(current_state_func)s(struct %(struct_name)s *fsm)
{
	return fsm->current_state;
}

int
%(advance_func)s(struct %(struct_name)s *fsm, enum %(enum_name)s new_state,
    char *errbuf, size_t errlen)
{
	enum %(enum_name)s old_state;

	/* Sanity check states */
	if (_is_%(enum_name)s_valid(fsm->current_state) != 0) {
		if (errlen > 0 && errbuf != NULL) {
			snprintf(errbuf, errlen, "Invalid current_state (%%d)",
			    fsm->current_state);
		}
		return -1;
	}
	if (_is_%(enum_name)s_valid(new_state) != 0) {
		if (errlen > 0 && errbuf != NULL) {
			snprintf(errbuf, errlen, "Invalid new_state (%%d)",
			    fsm->current_state);
		}
		return -1;
	}

	/* Transition checks */
	switch (fsm->current_state) {
%(transition_check)s	}
%(entry_preconds)s%(exit_preconds)s
	/* Switch state now */
	old_state = fsm->current_state;
	fsm->current_state = new_state;
%(trans_funcs)s
	return 0;

 bad_transition:
	if (errlen > 0 && errbuf != NULL) {
		snprintf(errbuf, errlen,
		    "Illegal state transition attempted: %%s -> %%s",
		    %(enum_to_string_func)s_safe(fsm->current_state),
		    %(enum_to_string_func)s_safe(new_state));
	}
	return -1;
%(error_handlers)s}
"""

# -------------------------------------------------------------------------

if __name__ == '__main__': main()

