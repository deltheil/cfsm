#!/usr/bin/env python

# Copyright 2007 Damien Miller <djm@mindrot.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# I assert no rights over the output of the cfsm program (i.e. the
# generated C source file, header and dot graph). If you find cfsm
# useful and use it in your project, then a credit notice in the source
# or documentation would be appreciated, but is not required.

import re
import sys
import getopt

def usage():
	print """
cfsm.py -- Finite state machine compiler
Usage: cfsm.py [-h] [-C source.c] [-H header.h] [-D dotfile.dot] input.fsm

Command-line flags:
        -h             Display this help
        -C path        Output C source to "path"
        -H path        Output C header to "path"
        -D path        Output graphviz dot graph to "path"
"""

def main():
	try:
		opts, args = getopt.getopt(sys.argv[1:], 'C:D:H:h')
	except getopt.GetoptError:
		print >> sys.stderr, "Error: Invalid commandline arguments"
		usage()
		sys.exit(1)

	source_file = None
	header_file = None
	dot_file = None
	for o, a in opts:
		if o in ('-h', '--help'):
			usage()
			sys.exit(0)
		if o in ('-C', '--source'):
			source_file = a
		if o in ('-D', '--dot'):
			dot_file = a
		if o in ('-H', '--heder'):
			header_file = a
	if len(args) != 1:
		print >> sys.stderr, "Error: No input file specified"
		usage()
		sys.exit(1)

	input_path = args[0]

	if source_file is None and header_file is None and dot_file is None:
		print >> sys.stderr, "Error: No output file(s) specified"
		usage()
		sys.exit(1)

	keywords = {
		'state'				: [ False, 2 ],
		'next-state'			: [ True, 2 ],
		'entry-precondition'		: [ True, 2 ],
		'onentry-func'			: [ True, 2 ],
		'exit-precondition'		: [ True, 2 ],
		'onexit-func'			: [ True, 2 ],
		'initial-state'			: [ True, 1 ],
		'fsm-struct-type'		: [ False, 2 ],
		'state-enum-type'		: [ False, 2 ],
		'advance-function'		: [ False, 2 ],
		'free-function'			: [ False, 2 ],
		'initialise-function'		: [ False, 2 ],
		'initialize-function'		: [ False, 2 ],
		'current-state-function'	: [ False, 2 ],
		'enum-to-string-function'	: [ False, 2 ],
		'source-banner'			: [ False, 1 ],
	}

	lnum = 0
	fsm = FSM()
	state = None
	banner = None
	input_file = open(input_path)
	for line in input_file:
		lnum += 1
		comment_ndx = line.find('#')
		if comment_ndx != -1:
			line = line[:comment_ndx]
		line = line.strip()
		if line == "":
			continue

		terms = line.split()
		if not terms[0] in keywords:
			print >> sys.stderr, "line %d:" % lnum, \
			    "unsupported directive \"%s\"" % terms[0]
			sys.exit(1)
		if len(terms) != keywords[terms[0]][1]:
			print >> sys.stderr, "line %d:" % lnum, \
			    "syntax error"
			sys.exit(1)
		if keywords[terms[0]][0] and state is None:
			print >> sys.stderr, "line %d:" % lnum, \
			    terms[0], "cannot be used outside of", \
			    "a state definition"
			sys.exit(1)

		try:
			if terms[0] == 'state':
				if state is not None:
					fsm.add_state(state)
				state = State(terms[1])
			elif terms[0] == 'next-state':
				state.add_next_state(terms[1])
				# XXX support:
				# next-state FOO transition_func
			elif terms[0] == 'entry-precondition':
				state.add_pre_entry_func(terms[1])
			elif terms[0] == 'onentry-func':
				state.add_post_entry_func(terms[1])
			elif terms[0] == 'exit-precondition':
				state.add_pre_exit_func(terms[1])
			elif terms[0] == 'onexit-func':
				state.add_post_exit_func(terms[1])
			elif terms[0] == 'initial-state':
				state.initial = True
			elif terms[0] == 'fsm-struct-type':
				fsm.struct_name = terms[1]
			elif terms[0] == 'state-enum-type':
				fsm.enum_name = terms[1]
			elif terms[0] == 'initialise-function' or \
			     terms[0] == 'initialize-function':
				fsm.init_func = terms[1]
			elif terms[0] == 'free-function':
				fsm.free_func = terms[1]
			elif terms[0] == 'advance-function':
				fsm.advance_func = terms[1]
			elif terms[0] == 'current-state-function':
				fsm.cuttent_state_func = terms[1]
			elif terms[0] == 'enum-to-string-function':
				fsm.enum_to_string_func = terms[1]
			elif terms[0] == 'source-banner':
				source_banner = ""
				for l in input_file:
					lnum += 1
					if l.startswith('end-source-banner'):
						break
					source_banner += l
				if not l.startswith('end-source-banner'):
					raise ValueError, \
					   "EOF looking for end-source-banner"
				fsm.source_banner = source_banner

		except ValueError, e:
				print >> sys.stderr, "line %d:" % lnum, e
				sys.exit(1)

	if state is not None:
		fsm.add_state(state)

	try:
		fsm.finalise()
	except ValueError, e:
		print >> sys.stderr, e
		sys.exit(1)

	if header_file is not None:
		fsm.output_header(open(header_file, "w"), header_file)
	if source_file is not None:
		fsm.output_source(open(source_file, "w"), header_file)
	if dot_file is not None:
		fsm.output_dot(open(dot_file, "w"))

class FSM:
	def __init__(self):
		self.state_list = []
		self.states = {}
		self.enum_name = "state"
		self.struct_name = "fsm"
		self.free_func = "state_free"
		self.init_func = "state_init"
		self.advance_func = "state_advance"
		self.enum_to_string_func = "state_ntop"
		self.current_state_func = "state_current"
		self.source_banner = None

	def add_state(self, state):
		if state.name in self.states:
			raise ValueError, "State %s already added" % state.name
		self.state_list.append(state)
		self.states[state.name] = state

	def finalise(self):
		indegrees = dict([ (s, 0) for s in self.states])
		for state in self.states:
			for arc in self.states[state].next_states:
				if not arc in self.states:
					raise ValueError, "State " + state + \
					    " refers to nonexistent " + \
					    "next-state " + arc
				indegrees[arc] += 1
		for state in indegrees:
			if indegrees[state] == 0 and \
			   not self.states[state].initial:
				raise ValueError, "Unreachable state " + state
			
	def _output_selfpromotion(self, h):
		print >> h, \
"""/*
 * Automatically generated using the cfsm FSM compiler:
 * http://www.mindrot.org/projects/cfsm/
 */
"""

	def output_header(self, h, filename):
		guard = filename.upper().replace('/', '__').replace('.', '_')
		if self.source_banner is not None:
			print >> h, self.source_banner
		self._output_selfpromotion(h)
		print >> h, \
"""#ifndef %s
#define %s

#include <sys/types.h>

/*
 * The valid states of the FSM
 */
enum %s {""" % (guard, guard, self.enum_name)
		i = 0
		for state in self.state_list:
			print >> h, "	%s = %u," % (state.name, i)
			i += 1

		init_states = [s.name for s in self.state_list if s.initial]
		need_init = len(init_states) > 1

		print >> h, \
"""};

/*
 * The FSM object itself. This is intentionally opaque - all access must be
 * through this API
 */
struct %s;""" % (self.struct_name)

		if need_init:
			print >> h, \
"""
/*
 * Allocate a new FSM and set its starting state to "initial_state".
 * Will return a pointer to the opaque FSM structure on success or 
 * NULL on failure. If "errbuf" is not NULL, upto "errlen" bytes of
 * error message will be copied into "errbuf" on failure.
 */
struct %(struct)s *%(init_func)s(enum %(enum_name)s initial_state,
    char *errbuf, size_t errlen);
""" % {
			    "struct" : self.struct_name,
			    "init_func" : self.init_func,
			    "enum_name" : self.enum_name
			}
		else:
			print >> h, \
"""
/*
 * Allocate a new FSM and set its starting state to %(init_state)s
 * Will return a pointer to the opaque FSM structure on success or 
 * NULL on failure. If "errbuf" is not NULL, upto "errlen" bytes of
 * error message will be copied into "errbuf" on failure.
 */
struct %(struct)s *%(init)s(char *errbuf, size_t errlen);
""" % {
			    "struct" : self.struct_name,
			    "init" : self.init_func,
			    "init_state" : init_states[0]
			}


		print >> h, \
"""/*
 * Free a FSM created with %(init_func)s()
 */
void %(free_func)s(struct %(struct_name)s *fsm);

/*
 * Attempt to advance to the state specified by "new_state". Will return
 * 0 on success, -1 on failure. If "errbuf" is not NULL, upto "errlen"
 * bytes of error message will be copied into "errbuf" on failure.
 */
int %(advance_func)s(struct %(struct_name)s *fsm, enum %(enum_name)s new_state,
    char *errbuf, size_t errlen);

/*
 * Convert from the %(enum_name)s enumeration to a string. Will return
 * NULL if the state is not known.
 */
const char *%(enum_to_string_func)s(enum %(enum_name)s);

/*
 * "Safe" version of %(enum_to_string_func)s. Will return the string
 * "[INVALID]" if the state is not known, so it can be used directly
 * in printf() statements, etc.
 */
const char *%(enum_to_string_func)s_safe(enum %(enum_name)s);

/*
 * Returns the current state of the FSM.
 */
enum %(enum_name)s %(current_state_func)s(struct %(struct_name)s *fsm);
""" % {
		    "struct_name" : self.struct_name,
		    "enum_name" : self.enum_name,
		    "init_func" : self.init_func,
		    "free_func" : self.free_func,
		    "advance_func" : self.advance_func,
		    "enum_to_string_func" : self.enum_to_string_func,
		    "current_state_func" : self.current_state_func
		}
		print >> h, "#endif /* %s */" % guard

	def _output_state_validity_checks(self, h):
		# Output current_state and new_state sanity checks
		print >> h, \
"""	/* Sanity check states */
	if (!(fsm->current_state >= %(ok1)s &&
	    fsm->current_state <= %(ok2)s)) {
		if (errlen > 0 && errbuf != NULL) {
			snprintf(errbuf, errlen, "Invalid current_state (%%d)",
			    fsm->current_state);
		}
		return -1;
	}
	if (!(new_state >= %(ok1)s &&
	    new_state <= %(ok2)s)) {
		if (errlen > 0 && errbuf != NULL) {
			snprintf(errbuf, errlen, "Invalid new_state (%%d)",
			    fsm->current_state);
		}
		return -1;
	}""" % {
		    "ok1" : self.state_list[0].name,
		    "ok2" : self.state_list[-1].name,
		}

	def _output_transition_checks(self, h):
		# XXX this might be better done using an adjacency matrix
		#     (perhaps packed into a bit vector for space)
		# Output transition validity checking
		print >> h, """
	/* Transition checks */
	switch (fsm->current_state) {"""
		for state in self.state_list:
			print >> h, "	case %s:" % state.name
			if len(state.next_states) == 0:
				print >> h, "		goto bad_transition;"
				continue
			print >> h, "		switch (new_state) {"
			for arc in state.next_states:
				print >> h, "		case %s:" % arc
			print >> h, "			break;"
			print >> h, "		default:"
			print >> h, "			goto bad_transition;"
			print >> h, "		}"
			print >> h, "		break;"
		print >> h, "	}\n"

	def _output_state_change_calls(self, h, what, which, attr, critical):
		# Output state change precondition/entry/exit calls
		# This could be folded into the transition checking switch,
		# but the code would be IMHO less readable
		if which == "entry":
			var = "new_state"
		elif which == "exit":
			var = "fsm->current_state"
		else:
			raise ValueError, "bogus which \"%s\"" % which

		switch_started = False
		for state in self.state_list:
			funcs = getattr(state, attr)
			if len(funcs) == 0:
				continue
			if not switch_started:
				print >> h, "	/* %s %s */" % (which, what)
				print >> h, "	switch (%s) {" % var
				switch_started = True
			print >> h, "	case %s:" % state.name
			for func in funcs:
				func_call = func + \
				    "(fsm->current_state, new_state)"
				if critical:
					print >> h, \
					    "\t\tif (%s != 0)" % func_call
					print >> h, \
					    "\t\t\tgoto %s_precond_fail;" % \
					    which
				else:
					print >> h, "\t\t%s;" % func_call
			print >> h, "		break;"
		if switch_started:
			print >> h, "	default:"
			print >> h, \
			    "		break; /* Hush compiler warnings */"
			print >> h, "	}\n"
		return switch_started

	def _output_preconditions(self, h):
		i = self._output_state_change_calls(h, "preconditions",
		    "exit", "pre_exit_funcs", True)
		o = self._output_state_change_calls(h, "preconditions",
		    "entry", "pre_entry_funcs", True)
		return i, o
				
	def _output_transition_calls(self, h):
		self._output_state_change_calls(h, "transition functions",
		    "exit", "post_exit_funcs", False)
		self._output_state_change_calls(h, "transition functions",
		    "entry", "post_entry_funcs", False)

	def _output_state_func_prototypes(self, h):
		actions = {}
		preconds = {}
		for state in self.state_list:
			for func in state.pre_entry_funcs:
				preconds[func] = True
			for func in state.pre_exit_funcs:
				preconds[func] = True
			for func in state.post_entry_funcs:
				actions[func] = True
			for func in state.post_exit_funcs:
				actions[func] = True
		if len(actions) > 0:
			print >> h, "/* Prototypes for transition functions */"
		for func in actions:
			print >> h, "void %s(enum %s, enum %s);" % \
			    (func, self.enum_name, self.enum_name)
		print >> h, ""
		if len(preconds) > 0:
			print >> h, "/* Prototypes for precondition checks */"
		for func in preconds:
			print >> h, "int %s(enum %s, enum %s);" % \
			    (func, self.enum_name, self.enum_name)
		print >> h, ""
			
	def _output_private_struct_decl(self, h):
		print >> h, \
"""
/* Private view of opaque FSM structure */
struct %(struct_name)s {
	enum %(enum_name)s current_state;
};
""" % { "enum_name" : self.enum_name, "struct_name" : self.struct_name }

	def _output_state_advance_func(self, h):
		print >> h, \
"""int
%(advance_func)s(struct %(struct_name)s *fsm, enum %(enum_name)s new_state,
    char *errbuf, size_t errlen)
{
	enum %(enum_name)s old_state;
""" % {
		    "advance_func": self.advance_func,
		    "enum_name" : self.enum_name,
		    "struct_name" : self.struct_name
		}

		self._output_state_validity_checks(h)
		self._output_transition_checks(h)
		precond_entry, precond_exit = self._output_preconditions(h)

		print >> h, \
"""	/* Switch state now */
	old_state = fsm->current_state;
	fsm->current_state = new_state;
"""
		self._output_transition_calls(h)

		print >> h, \
"""	return 0;

 bad_transition:
	if (errlen > 0 && errbuf != NULL) {
		snprintf(errbuf, errlen,
		    "Illegal state transition attempted: %%s -> %%s",
		    %(enum_to_string)s_safe(fsm->current_state),
		    %(enum_to_string)s_safe(new_state));
	}
	return -1;""" % { "enum_to_string" : self.enum_to_string_func }

		if precond_entry:
			print >> h, \
""" entry_precond_fail:
	if (errlen > 0 && errbuf != NULL) {
		snprintf(errbuf, errlen,
		    "State %%s entry precondition not satisfied",
		    %(enum_to_string)s_safe(new_state));
	}
	return -1;""" % { "enum_to_string" : self.enum_to_string_func }

		if precond_exit:
			print >> h, \
""" exit_precond_fail:
	if (errlen > 0 && errbuf != NULL) {
		snprintf(errbuf, errlen,
		    "State %%s exit precondition not satisfied",
		    %(enum_to_string)s_safe(fsm->current_state));
	}
	return -1;""" % { "enum_to_string" : self.enum_to_string_func }

		print >> h, "}\n"

	def _output_state_init_func(self, h):
		init_states = [s.name for s in self.state_list if s.initial]
		need_init = len(init_states) > 1
		
		if need_init:
			print >> h, \
"""struct %(struct_name)s *
%(init_func)s(enum %(enum_name)s initial_state, char *errbuf, size_t errlen)
{
	struct %(struct_name)s *ret = NULL;

	switch (initial_state) {""" % {
			    "init_func" : self.init_func,
			    "enum_name" : self.enum_name,
			    "struct_name" : self.struct_name
			}

			for state in init_states:
				print >> h, "	case %s:" % state
			print >> h, \
"""		break;
	default:
		if (errlen > 0 && errbuf != NULL) {
			snprintf(errbuf, errlen,
			    "State %%s (%%d) is not a valid start state",
			    %(enum_to_string)s_safe(initial_state),
			    initial_state);
		}
		return NULL;
	}
	if ((ret = calloc(1, sizeof(*ret))) == NULL) {
		if (errlen > 0 && errbuf != NULL)
			snprintf(errbuf, errlen, "Memory allocation failed");
		return NULL;
	}
	ret->current_state = initial_state;
	return ret;
}
""" % { "enum_to_string" : self.enum_to_string_func }
		else:
			print >> h, \
"""struct %(struct_name)s *
%(init_func)s(char *errbuf, size_t errlen)
{
	struct %(struct_name)s *ret = NULL;

	if ((ret = calloc(1, sizeof(*ret))) == NULL) {
		if (errlen > 0 && errbuf != NULL)
			snprintf(errbuf, errlen, "Memory allocation failed");
		return NULL;
	}
	ret->current_state = %(initial_state)s;
	return ret;
}""" % {
			    "init_func" : self.init_func,
			    "enum_name" : self.enum_name,
			    "struct_name" : self.struct_name,
			    "initial_state" : init_states[0]
			}

	def _output_state_free_func(self, h):
		print >> h, \
"""void
%(free_func)s(struct %(struct_name)s *fsm)
{
	memset(fsm, '\\0', sizeof(fsm));
	free(fsm);
}
""" % { "free_func" : self.free_func, "struct_name" : self.struct_name }

	def _output_enum_to_string_funcs(self, h):
		print >> h, \
"""const char *
%s(enum %s n)
{
	const char *state_names[] = {""" % \
		    (self.enum_to_string_func, self.enum_name)
		for state in self.state_list:
			print >> h, "		\"%s\"," % state.name
		print >> h, \
"""	};

	if (!(n >= %(ok1)s && n <= %(ok2)s))
		return NULL;
	return state_names[n];
}
""" % { "ok1" : self.state_list[0].name, "ok2" : self.state_list[-1].name }
		print >> h, """
const char *
%s_safe(enum %s n)
{
	const char *r = %s(n);

	return r == NULL ? "[INVALID]" : r;
}
""" % (self.enum_to_string_func, self.enum_name, self.enum_to_string_func)

	def _output_current_state_func(self, h):
		print >> h, \
"""enum %(enum_name)s
%(current_state_func)s(struct %(struct_name)s *fsm)
{
	return fsm->current_state;
}
""" % {
		    "enum_name" : self.enum_name,
		    "struct_name" : self.struct_name,
		    "current_state_func" : self.current_state_func
		}

	def output_source(self, h, header_path):
		if self.source_banner is not None:
			print >> h, self.source_banner 
		self._output_selfpromotion(h)

		print >> h, "#include <sys/types.h>\n"
		print >> h, "#include <stdlib.h>"
		print >> h, "#include <string.h>"
		print >> h, "#include <stdio.h>\n"
		print >> h, "#include \"%s\"" % header_path

		self._output_private_struct_decl(h)
		self._output_state_func_prototypes(h)
		self._output_enum_to_string_funcs(h)
		self._output_state_init_func(h)
		self._output_state_free_func(h)
		self._output_state_advance_func(h)
		self._output_current_state_func(h)

	def output_dot(self, h):
		# XXX pretty basic. Doesn't show preconditions, etc.
		print >> h, "digraph FSM {"
		print >> h, "	rankdir = LR;"
		print >> h, "	node [shape = doublecircle];",
		for state in self.state_list:
			if not state.initial:
				continue;
			print >> h, state.name,
		print >> h, "\n	node [shape = circle];",
		for state in self.state_list:
			if state.initial:
				continue;
			print >> h, state.name,
		print >> h, ""
		for state in self.state_list:
			for arc in state.next_states:
				print >> h, "	%s -> %s;" % (state.name, arc)
		print >> h, "}"

class State:
	def __init__(self, name):
		self._name_check(name)
		self.name = name
		self.next_states = []
		self.pre_entry_funcs = []
		self.post_entry_funcs = []
		self.pre_exit_funcs = []
		self.post_exit_funcs = []
		self.initial = False
	def _name_check(self, name):
		if re.match('^[A-Za-z_][A-Za-z0-9_]*$', name) is None:
			raise ValueError, "Invalid name \"%s\"" % name
	def add_next_state(self, name):
		self._name_check(name)
		self.next_states.append(name)
	def add_pre_entry_func(self, name):
		self._name_check(name)
		self.pre_entry_funcs.append(name)
	def add_post_entry_func(self, name):
		self._name_check(name)
		self.post_entry_funcs.append(name)
	def add_pre_exit_func(self, name):
		self._name_check(name)
		self.pre_exit_funcs.append(name)
	def add_post_exit_func(self, name):
		self._name_check(name)
		self.post_exit_funcs.append(name)

if __name__ == '__main__': main()

