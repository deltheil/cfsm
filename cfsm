#!/usr/bin/env python

# Copyright 2007 Damien Miller <djm@mindrot.org>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

# I assert no rights over the output of the cfsm program (i.e. the
# generated C source file, header and dot graph). If you find cfsm
# useful and use it in your project, then a credit notice in the source
# or documentation would be appreciated, but is not required.

import re
import sys
import getopt

def usage():
	print """
cfsm.py -- Finite state machine compiler
Usage: cfsm.py [-h] [-C source.c] [-H header.h] [-D dotfile.dot] input.fsm

Command-line flags:
        -h             Display this help
        -C path        Output C source to "path"
        -H path        Output C header to "path"
        -D path        Output graphviz dot graph to "path"
"""

def main():
	try:
		opts, args = getopt.getopt(sys.argv[1:], 'C:D:H:h')
	except getopt.GetoptError:
		print >> sys.stderr, "Error: Invalid commandline arguments"
		usage()
		sys.exit(1)

	source_file = None
	header_file = None
	dot_file = None
	for o, a in opts:
		if o in ('-h', '--help'):
			usage()
			sys.exit(0)
		if o in ('-C', '--source'):
			source_file = a
		if o in ('-D', '--dot'):
			dot_file = a
		if o in ('-H', '--heder'):
			header_file = a
	if len(args) != 1:
		print >> sys.stderr, "Error: No input file specified"
		usage()
		sys.exit(1)

	input_path = args[0]

	if source_file is None and header_file is None and dot_file is None:
		print >> sys.stderr, "Error: No output file(s) specified"
		usage()
		sys.exit(1)

	keywords = {
		'state'				: [ None, 2 ],
		'next-state'			: [ 'state', 2 ],
		'entry-precondition'		: [ 'state', 2 ],
		'onentry-func'			: [ 'state', 2 ],
		'exit-precondition'		: [ 'state', 2 ],
		'onexit-func'			: [ 'state', 2 ],
		'initial-state'			: [ 'state', 1 ],
		'on-event'			: [ 'state', 4 ],
		'event-precondition'		: [ 'event', 2 ],
		'event-callback'			: [ 'event', 2 ],
		'event'				: [ None, 2 ],
		'fsm-struct-type'		: [ None, 2 ],
		'state-enum-type'		: [ None, 2 ],
		'event-enum-type'		: [ None, 2 ],
		'advance-function'		: [ None, 2 ],
		'event-function'		: [ None, 2 ],
		'free-function'			: [ None, 2 ],
		'initialise-function'		: [ None, 2 ],
		'initialize-function'		: [ None, 2 ],
		'current-state-function'	: [ None, 2 ],
		'state-enum-to-string-function'	: [ None, 2 ],
		'event-enum-to-string-function'	: [ None, 2 ],
		'source-banner'			: [ None, 1 ],
		'precondition-function-args'	: [ None, 2 ],
		'transition-function-args'	: [ None, 2 ],
		'event-callback-args'		: [ None, 2 ],
		'event-precondition-args'	: [ None, 2 ],
	}

	lnum = 0
	fsm = FSM()
	state = None
	event = None
	banner = None
	input_file = open(input_path)
	for line in input_file:
		lnum += 1
		comment_ndx = line.find('#')
		if comment_ndx != -1:
			line = line[:comment_ndx]
		line = line.strip()
		if line == "":
			continue

		terms = line.split()
		if not terms[0] in keywords:
			print >> sys.stderr, "line %d:" % lnum, \
			    "unsupported directive \"%s\"" % terms[0]
			sys.exit(1)
		expected_state, num_terms = keywords[terms[0]]
		if len(terms) != num_terms:
			print >> sys.stderr, "line %d:" % lnum, \
			    "syntax error"
			sys.exit(1)
		if expected_state == 'state' and state is None:
			print >> sys.stderr, "line %d:" % lnum, \
			    terms[0], "cannot be used outside of", \
			    "a state definition"
			sys.exit(1)
		if expected_state == 'event' and event is None:
			print >> sys.stderr, "line %d:" % lnum, \
			    terms[0], "cannot be used outside of", \
			    "an event definition"
			sys.exit(1)

		try:
			if terms[0] == 'state':
				state = fsm.get_state(terms[1])
				event = None
			elif terms[0] == 'event':
				event = fsm.get_event(terms[1])
				state = None
			elif terms[0] == 'on-event':
				if terms[2] != "->":
					raise ValueError, "Invalid syntax"
				event = fsm.get_event(terms[1])
				fsm.add_transition(state.name, terms[3], event)
			elif terms[0] == 'next-state':
				fsm.add_transition(state.name, terms[1])
			elif terms[0] == 'entry-precondition':
				state.add_pre_entry_func(terms[1])
			elif terms[0] == 'onentry-func':
				state.add_post_entry_func(terms[1])
			elif terms[0] == 'event-precondition':
				event.add_pre_entry_func(terms[1])
			elif terms[0] == 'event-callback':
				event.add_post_entry_func(terms[1])
			elif terms[0] == 'exit-precondition':
				state.add_pre_exit_func(terms[1])
			elif terms[0] == 'onexit-func':
				state.add_post_exit_func(terms[1])
			elif terms[0] == 'initial-state':
				state.initial = True
			elif terms[0] == 'fsm-struct-type':
				fsm.struct_name = terms[1]
			elif terms[0] == 'state-enum-type':
				fsm.state_enum = terms[1]
			elif terms[0] == 'event-enum-type':
				fsm.event_enum = terms[1]
			elif terms[0] == 'initialise-function' or \
			     terms[0] == 'initialize-function':
				fsm.init_func = terms[1]
			elif terms[0] == 'free-function':
				fsm.free_func = terms[1]
			elif terms[0] == 'advance-function':
				fsm.advance_func = terms[1]
			elif terms[0] == 'current-state-function':
				fsm.current_state_func = terms[1]
			elif terms[0] == 'state-enum-to-string-function':
				fsm.state_enum_to_string_func = terms[1]
			elif terms[0] == 'event-enum-to-string-function':
				fsm.event_enum_to_string_func = terms[1]
			elif terms[0] == 'source-banner':
				source_banner = ""
				for l in input_file:
					lnum += 1
					if l.startswith('end-source-banner'):
						break
					source_banner += l
				if not l.startswith('end-source-banner'):
					raise ValueError, \
					   "EOF looking for end-source-banner"
				fsm.source_banner = source_banner
			elif terms[0] == 'precondition-function-args':
				fsm.precond_arg_event = False
				fsm.precond_arg_curr = False
				fsm.precond_arg_new = False
				fsm.precond_arg_ctx = False
				for arg in terms[1].split(','):
					arg = arg.strip()
					if arg == 'none':
						pass
					elif arg == 'event':
						fsm.precond_arg_event = True
					elif arg == 'old-state':
						fsm.precond_arg_curr = True
					elif arg == 'new-state':
						fsm.precond_arg_new = True
					elif arg == 'ctx':
						fsm.precond_arg_ctx = True
					else:
						raise ValueError, \
						    "Invalid %s argument %s" % \
						    (terms[0], terms[1])
			elif terms[0] == 'transition-function-args':
				fsm.trans_arg_event = False
				fsm.trans_arg_curr = False
				fsm.trans_arg_new = False
				fsm.trans_arg_ctx = False
				for arg in terms[1].split(','):
					arg = arg.strip()
					if arg == 'none':
						pass
					elif arg == 'event':
						fsm.trans_arg_event = True
					elif arg == 'old-state':
						fsm.trans_arg_curr = True
					elif arg == 'new-state':
						fsm.trans_arg_new = True
					elif arg == 'ctx':
						fsm.trans_arg_ctx = True
					else:
						raise ValueError, \
						    "Invalid %s argument %s" % \
						    (terms[0], terms[1])
			elif terms[0] == 'event-precondition-args':
				fsm.ev_precond_arg_event = False
				fsm.ev_precond_arg_curr = False
				fsm.ev_precond_arg_new = False
				fsm.ev_precond_arg_ctx = False
				for arg in terms[1].split(','):
					arg = arg.strip()
					if arg == 'none':
						pass
					elif arg == 'event':
						fsm.ev_precond_arg_event = True
					elif arg == 'old-state':
						fsm.ev_precond_arg_curr = True
					elif arg == 'new-state':
						fsm.ev_precond_arg_new = True
					elif arg == 'ctx':
						fsm.ev_precond_arg_ctx = True
					else:
						raise ValueError, \
						    "Invalid %s argument %s" % \
						    (terms[0], terms[1])
			elif terms[0] == 'event-callback-args':
				fsm.ev_callback_arg_event = False
				fsm.ev_callback_arg_curr = False
				fsm.ev_callback_arg_new = False
				fsm.ev_callback_arg_ctx = False
				for arg in terms[1].split(','):
					arg = arg.strip()
					if arg == 'none':
						pass
					elif arg == 'event':
						fsm.ev_callback_arg_event = True
					elif arg == 'old-state':
						fsm.ev_callback_arg_curr = True
					elif arg == 'new-state':
						fsm.ev_callback_arg_new = True
					elif arg == 'ctx':
						fsm.ev_callback_arg_ctx = True
					else:
						raise ValueError, \
						    "Invalid %s argument %s" % \
						    (terms[0], terms[1])

			else:
				raise ValueError, \
				    "unsupported keyworks \"%s\"" % terms[0]

		except ValueError, e:
				print >> sys.stderr, "line %d:" % lnum, e
				sys.exit(1)

	try:
		fsm.finalise()
				
	except ValueError, e:
		print >> sys.stderr, e
		sys.exit(1)

	if header_file is not None:
		fsm.output_header(open(header_file, "w"), header_file)
	if source_file is not None:
		fsm.output_source(open(source_file, "w"), header_file)
	if dot_file is not None:
		fsm.output_dot(open(dot_file, "w"))

class FSM:
	def __init__(self):
		self.state_list = []
		self.states = {}
		self.event_list = []
		self.events = {}
		self.transitions = {}
		self.state_enum = "state"
		self.event_enum = "state_events"
		self.struct_name = "fsm"
		self.free_func = "state_free"
		self.init_func = "state_init"
		self.advance_func = "state_advance"
		self.state_enum_to_string_func = "state_ntop"
		self.event_enum_to_string_func = "event_ntop"
		self.current_state_func = "state_current"
		self.source_banner = None
		self.precond_arg_event = True
		self.precond_arg_curr = True
		self.precond_arg_new = True
		self.precond_arg_ctx = True
		self.trans_arg_event = True
		self.trans_arg_curr = True
		self.trans_arg_new = True
		self.trans_arg_ctx = True
		self.ev_callback_arg_event = True
		self.ev_callback_arg_curr = True
		self.ev_callback_arg_new = True
		self.ev_callback_arg_ctx = True
		self.ev_precond_arg_event = True
		self.ev_precond_arg_curr = True
		self.ev_precond_arg_new = True
		self.ev_precond_arg_ctx = True

	def get_state(self, name):
		if name in self.states:
			return self.states[name]
		state = State(name)
		self.state_list.append(state)
		self.states[state.name] = state
		return state

	def get_event(self, name):
		if name in self.events:
			return self.events[name]
		event = Event(name)
		self.event_list.append(event)
		self.events[event.name] = event
		return event

	def add_transition(self, from_, to_, event = None):
		if event:
			event.add_next_state(from_, to_)
		self.states[from_].add_next_state(to_)
		tkey = from_ + " -> " + to_
		if tkey in self.transitions:
			if event is not None and \
			   self.transitions[tkey] is not None and \
			   self.transitions[tkey].name != event.name:
				raise ValueError, "different events (" + \
				    self.transitions[tkey].name + ", " + \
				    event.name + ") lead to the same " + \
				    "transition: " + tkey
		else:
			self.transitions[tkey] = event

	def finalise(self):
		reachable = set()
		for state in self.states.itervalues():
			if state.initial:
				continue
			reachable.add(state.name)
		# XXX check next-state vs event
		for event in self.events.itervalues():
			if len(event.next_states) == 0:
				raise ValueError, "Event " + event + \
					" triggers no transitions"
			for from_ in event.next_states:
				if not from_ in self.states:
					raise ValueError, "Event " + \
					    event.name + " refers to " + \
					    "nonexistent current state" + \
					    from_
				to_ = event.next_states[from_]
				reachable.discard(to_)
				if not from_ in self.states:
					raise ValueError, \
					    "Event " + event.name + \
					    " refers to nonexistent next " + \
					    "state" + to_
				self.add_transition(from_, to_, event)

		if len(self.events) != 0 and len(reachable) != 0:
			raise ValueError, "Some states unreachable via " + \
			    "events: " + ", ".join(reachable)
		indegrees = dict([(s, 0) for s in self.states])
		for state in self.states:
			for arc in self.states[state].next_states:
				if not arc in self.states:
					raise ValueError, "State " + state + \
					    " refers to nonexistent " + \
					    "next-state " + arc
				indegrees[arc] += 1
		for state in indegrees:
			if indegrees[state] == 0 and \
			   not self.states[state].initial:
				raise ValueError, "Unreachable state " + state
			
	def output_header(self, h, filename):
		guard = filename.upper().replace('/', '__').replace('.', '_')
		banner = ""
		if self.source_banner is not None:
			banner = banner + "\n"

		enum_contents = ""
		i = 0
		for state in self.state_list:
			enum_contents += "\t%s = %u,\n" % (state.name, i)
			i += 1
		event_enum_contents = ""
		i = 0
		for event in self.event_list:
			event_enum_contents += "\t%s = %u,\n" % (event.name, i)
			i += 1

		init_states = [s.name for s in self.state_list if s.initial]
		if len(init_states) > 1:
			init_func_proto_comments = _INIT_FUNC_MULTI
		else:
			init_func_proto_comments = _INIT_FUNC_SINGLE

		advance_ctx_arg = ""
		advance_ctx_comment = ""
		if self.precond_arg_ctx or self.trans_arg_ctx or \
		   (len(self.events) != 0 and self.ev_callback_arg_ctx):
			advance_ctx_arg = _ADVANCE_FUNC_CTX_ARG
			advance_ctx_comment = _ADVANCE_FUNC_CTX_COMMENT

 		init_func_proto_comments %= {
			    "struct_name" : self.struct_name,
			    "init_func" : self.init_func,
			    "state_enum" : self.state_enum,
			    "init_state" : init_states[0],
			}

		advance_func_comment = _ADVANCE_FUNC_COMMENT_STATE_BASED 
		advance_func_proto = _ADVANCE_FUNC_PROTO_STATE_BASED
		event_enum_decl = ""
		event_funcs_decl = ""
		if len(self.events):
			advance_func_comment = _ADVANCE_FUNC_COMMENT_EVENT_BASED 
			advance_func_proto = _ADVANCE_FUNC_PROTO_EVENT_BASED
			event_enum_decl = _EVENT_ENUM_DECL % {
			    "event_enum_contents" : event_enum_contents,
			    "event_enum" : self.event_enum,
			}
			event_funcs_decl = _EVENT_FUNCS_DECL % {
			    "event_enum" : self.event_enum,
			    "struct_name" : self.struct_name,
			    "event_enum_to_string_func" :
			        self.event_enum_to_string_func,
			}
		advance_func_proto %= {
		    "advance_func" : self.advance_func,
		    "state_enum" : self.state_enum,
		    "event_enum" : self.event_enum,
		    "struct_name" : self.struct_name,
		    "ctx" : advance_ctx_arg,
		}
		advance_func_comment %= {
		    "ctx" : advance_ctx_comment,
		}

		print >> h, _C_HEADER % {
		    "init_func_proto_comments" : init_func_proto_comments,
		    "enum_contents" : enum_contents,
		    "event_enum_optional" : event_enum_decl,
		    "event_funcs_optional" : event_funcs_decl,
		    "advance_func_comment" : advance_func_comment,
		    "advance_func_proto" : advance_func_proto,
		    "self_promotion" : _SELF_PROMOTION,
		    "banner" : banner,
		    "guard" : guard,
		    "struct_name" : self.struct_name,
		    "state_enum" : self.state_enum,
		    "event_enum" : self.event_enum,
		    "init_func" : self.init_func,
		    "free_func" : self.free_func,
		    "advance_func" : self.advance_func,
		    "current_state_func" : self.current_state_func,
		    "state_enum_to_string_func" :
		        self.state_enum_to_string_func,
		}

	def _build_state_func_prototypes(self):
		actions = {}
		preconds = {}
		for state in self.state_list:
			for func in state.pre_entry_funcs:
				preconds[func] = True
			for func in state.pre_exit_funcs:
				preconds[func] = True
			for func in state.post_entry_funcs:
				actions[func] = True
			for func in state.post_exit_funcs:
				actions[func] = True

		proto = []
		if self.trans_arg_event and len(self.event_list) > 0:
			proto.append(_TRANS_FUNC_PROTO_EVENT)
		if self.trans_arg_curr:
			proto.append(_TRANS_FUNC_PROTO_CURRENT)
		if self.trans_arg_new:
			proto.append(_TRANS_FUNC_PROTO_NEW)
		if self.trans_arg_ctx:
			proto.append(_TRANS_FUNC_PROTO_CTX)
		if len(proto) == 0:
			proto.append(_TRANS_FUNC_PROTO_NOARGS)
		trans_prototype = _TRANS_FUNC_PROTO_START
		trans_prototype += ", ".join(proto)
		trans_prototype += _TRANS_FUNC_PROTO_END

		proto = []
		if self.precond_arg_event and len(self.event_list) > 0:
			proto.append(_PRECOND_FUNC_PROTO_EVENT)
		if self.precond_arg_curr:
			proto.append(_PRECOND_FUNC_PROTO_CURRENT)
		if self.precond_arg_new:
			proto.append(_PRECOND_FUNC_PROTO_NEW)
		if self.precond_arg_ctx:
			proto.append(_PRECOND_FUNC_PROTO_CTX)
		if len(proto) == 0:
			proto.append(_PRECOND_FUNC_PROTO_NOARGS)
		precond_prototype = _PRECOND_FUNC_PROTO_START
		precond_prototype += ", ".join(proto)
		precond_prototype += _PRECOND_FUNC_PROTO_END

		ret = ""
		if len(actions) > 0:
			ret += _STATE_TRANS_FUNC_COMMENT
		for func in actions:
			ret += trans_prototype % {
			    "func" : func,
			    "state_enum" : self.state_enum,
			    "event_enum" : self.event_enum,
			}

		if len(preconds) > 0:
			ret += _STATE_PRECOND_FUNC_COMMENT
		for func in preconds:
			ret += precond_prototype % {
			    "func" : func,
			    "state_enum" : self.state_enum,
			    "event_enum" : self.event_enum,
			}
		return ret

	def _build_state_transition_checks(self):
		# XXX move this boilerplate code to template strings
		# XXX this might be better done using an adjacency matrix
		#     (perhaps packed into a bit vector for space)
		# Output transition validity checking
		ret = \
"""	/* Transition checks */
	switch (fsm->current_state) {
"""
		for state in self.state_list:
			ret += "	case %s:\n" % state.name
			if len(state.next_states) == 0:
				ret += "		goto bad_transition;\n"
				continue
			ret += "		switch (new_state) {\n"
			for arc in state.next_states:
				ret += "		case %s:\n" % arc
			ret += \
"""			break;
		default:
			goto bad_transition;
		}
		break;
"""
		ret += "	}"
		return ret

	def _build_event_transition_checks(self):
		# XXX move this boilerplate code to template strings
		# XXX this might be better done using an adjacency matrix
		#     (perhaps packed into a bit vector for space)
		# Output transition validity checking
		ret = \
"""	/* Determine next state */
	switch (fsm->current_state) {
"""
		for state in self.state_list:
			ret += "	case %s:\n" % state.name
			valid_events = [event for event in self.event_list
			    if state.name in event.next_states]
			if len(valid_events) == 0:
				ret += "		goto bad_event;\n"
				continue
			ret += "		switch (ev) {\n"
			for event in valid_events:
				ret += "\t\tcase %s:\n" % event.name
				ret += "\t\t\tnew_state = %s;\n" % \
				    event.next_states[state.name]
				ret += "\t\t\tbreak;\n"
			ret += \
"""		default:
			goto bad_event;
		}
		break;
"""
		ret += "	}"
		return ret

	def _build_state_calls(self, what, which, attr, critical, use_old=False):
		# Output state change precondition/entry/exit calls
		# This could be folded into the transition checking switch,
		# but the code would be IMHO less readable
		if which == "entry":
			var = "new_state"
		elif which == "exit":
			var = "fsm->current_state"
		else:
			raise ValueError, "bogus which \"%s\"" % which

		callsig = []
		if self.trans_arg_event:
			callsig.append(_TRANS_FUNC_CALLSIG_EVENT)
		if self.trans_arg_curr:
			if use_old:
				callsig.append(_TRANS_FUNC_CALLSIG_OLD)
			else:
				callsig.append(_TRANS_FUNC_CALLSIG_CURRENT)
		if self.trans_arg_new:
			callsig.append(_TRANS_FUNC_CALLSIG_NEW)
		if self.trans_arg_ctx:
			callsig.append(_TRANS_FUNC_CALLSIG_CTX)
		trans_callsig = _TRANS_FUNC_CALLSIG_START
		trans_callsig += ", ".join(callsig)
		trans_callsig += _TRANS_FUNC_CALLSIG_END

		callsig = []
		if self.precond_arg_event:
			callsig.append(_PRECOND_FUNC_CALLSIG_EVENT)
		if self.precond_arg_curr:
			callsig.append(_PRECOND_FUNC_CALLSIG_CURRENT)
		if self.precond_arg_new:
			callsig.append(_PRECOND_FUNC_CALLSIG_NEW)
		if self.precond_arg_ctx:
			callsig.append(_PRECOND_FUNC_CALLSIG_CTX)
		precond_callsig = _PRECOND_FUNC_CALLSIG_START
		precond_callsig += ", ".join(callsig)
		precond_callsig += _PRECOND_FUNC_CALLSIG_END

		switch_started = False
		ret = ""
		for state in self.state_list:
			funcs = getattr(state, attr)
			if len(funcs) == 0:
				continue
			if not switch_started:
				ret += _STATE_CALL_SWITCH_START % {
				    "which" : which,
				    "what" : what,
				    "var" : var,
				}
				switch_started = True
			ret += _STATE_CALL_SWITCH_CASE % { 
			    "state" : state.name
			}
			for func in funcs:
				if critical:
					frag = precond_callsig
				else:
					frag = trans_callsig
				ret += frag % {
				    "which" : which,
				    "func" : func
				}
			ret += "		break;\n"
		if switch_started:
			ret += _STATE_CALL_SWITCH_FINISH
		return ret

	def _build_event_calls(self, what, attr, critical):
		callsig = []
		if self.ev_callback_arg_event:
			callsig.append(_TRANS_FUNC_CALLSIG_EVENT)
		if self.ev_callback_arg_curr:
			callsig.append(_TRANS_FUNC_CALLSIG_CURRENT)
		if self.ev_callback_arg_new:
			callsig.append(_TRANS_FUNC_CALLSIG_NEW)
		if self.ev_callback_arg_ctx:
			callsig.append(_TRANS_FUNC_CALLSIG_CTX)
		trans_callsig = _TRANS_FUNC_CALLSIG_START
		trans_callsig += ", ".join(callsig)
		trans_callsig += _TRANS_FUNC_CALLSIG_END

		callsig = []
		if self.ev_precond_arg_event:
			callsig.append(_PRECOND_FUNC_CALLSIG_EVENT)
		if self.ev_precond_arg_curr:
			callsig.append(_PRECOND_FUNC_CALLSIG_CURRENT)
		if self.ev_precond_arg_new:
			callsig.append(_PRECOND_FUNC_CALLSIG_NEW)
		if self.ev_precond_arg_ctx:
			callsig.append(_PRECOND_FUNC_CALLSIG_CTX)
		precond_callsig = _PRECOND_FUNC_CALLSIG_START
		precond_callsig += ", ".join(callsig)
		precond_callsig += _PRECOND_FUNC_CALLSIG_END

		switch_started = False
		ret = ""
		for event in self.event_list:
			funcs = getattr(event, attr)
			if len(funcs) == 0:
				continue
			if not switch_started:
				ret += _EVENT_CALL_SWITCH_START % {
				    "what" : what,
				}
				switch_started = True
			ret += _EVENT_CALL_SWITCH_CASE % { 
			    "event" : event.name
			}
			for func in funcs:
				if critical:
					frag = precond_callsig
				else:
					frag = trans_callsig
				ret += frag % {
				    "func" : func,
				    "which" : "event",
				}
			ret += "		break;\n"
		if switch_started:
			ret += _EVENT_CALL_SWITCH_FINISH
		return ret

	def _build_event_func_prototypes(self):
		actions = {}
		preconds = {}
		for event in self.event_list:
			for func in event.pre_entry_funcs:
				preconds[func] = True
			for func in event.post_entry_funcs:
				actions[func] = True

		proto = []
		if self.ev_callback_arg_event:
			proto.append(_TRANS_FUNC_PROTO_EVENT)
		if self.ev_callback_arg_curr:
			proto.append(_TRANS_FUNC_PROTO_CURRENT)
		if self.ev_callback_arg_new:
			proto.append(_TRANS_FUNC_PROTO_NEW)
		if self.ev_callback_arg_ctx:
			proto.append(_TRANS_FUNC_PROTO_CTX)
		if len(proto) == 0:
			proto.append(_TRANS_FUNC_PROTO_NOARGS)
		trans_prototype = _TRANS_FUNC_PROTO_START
		trans_prototype += ", ".join(proto)
		trans_prototype += _TRANS_FUNC_PROTO_END

		proto = []
		if self.ev_precond_arg_event:
			proto.append(_PRECOND_FUNC_PROTO_EVENT)
		if self.ev_precond_arg_curr:
			proto.append(_PRECOND_FUNC_PROTO_CURRENT)
		if self.ev_precond_arg_new:
			proto.append(_PRECOND_FUNC_PROTO_NEW)
		if self.ev_precond_arg_ctx:
			proto.append(_PRECOND_FUNC_PROTO_CTX)
		if len(proto) == 0:
			proto.append(_PRECOND_FUNC_PROTO_NOARGS)
		precond_prototype = _PRECOND_FUNC_PROTO_START
		precond_prototype += ", ".join(proto)
		precond_prototype += _PRECOND_FUNC_PROTO_END

		ret = ""
		if len(actions) > 0:
			ret += _EVENT_TRANS_FUNC_COMMENT
		for func in actions:
			ret += trans_prototype % {
			    "func" : func,
			    "state_enum" : self.state_enum,
			    "event_enum" : self.event_enum,
			}

		if len(preconds) > 0:
			ret += _EVENT_PRECOND_FUNC_COMMENT
		for func in preconds:
			ret += precond_prototype % {
			    "func" : func,
			    "state_enum" : self.state_enum,
			    "event_enum" : self.event_enum,
			}
		return ret

	def build_event_funcs(self):		
		enum_contents = ""
		for event in self.event_list:
			enum_contents += "\t\t\"%s\",\n" % event.name

		event_funcs = _EVENT_FUNCTIONS % {
		    "min_event_valid" : self.event_list[0].name,
		    "max_event_valid" : self.event_list[-1].name,
		    "struct_name" : self.struct_name,
		    "state_enum" : self.state_enum,
		    "event_enum" : self.event_enum,
		    "enum_contents" : enum_contents,
		    "event_enum_to_string_func" :
		        self.event_enum_to_string_func,
		}
		return event_funcs

	def output_source(self, h, header_path):
		banner = ""
		if self.source_banner is not None:
			banner = self.source_banner + "\n"

		advance_ctx_arg = ""
		if self.precond_arg_ctx or self.trans_arg_ctx or \
		   (len(self.events) != 0 and self.ev_callback_arg_ctx):
			advance_ctx_arg = _ADVANCE_FUNC_CTX_ARG

		state_func_prototypes = self._build_state_func_prototypes()
		event_func_prototypes = self._build_event_func_prototypes()
		exit_preconds = self._build_state_calls("preconditions",
		    "exit", "pre_exit_funcs", True)
		entry_preconds = self._build_state_calls("preconditions",
		    "entry", "pre_entry_funcs", True)
		exit_funcs = self._build_state_calls("transition functions",
		    "exit", "post_exit_funcs", False)
		entry_funcs = self._build_state_calls("transition functions",
		    "entry", "post_entry_funcs", False, True)

		event_preconds = self._build_event_calls("event preconditions",
		    "pre_entry_funcs", True)
		event_callbacks = self._build_event_calls("event callbacks",
		    "post_entry_funcs", False)
		
		enum_contents = ""
		for state in self.state_list:
			enum_contents += "\t\t\"%s\",\n" % state.name

		init_states = [s.name for s in self.state_list if s.initial]
		if len(init_states) > 1:
			init_func_def = _STATE_INIT_FUNC_MULTI
		else:
			init_func_def = _STATE_INIT_FUNC_SINGLE
		init_state_cases = \
		    "\n".join(["\tcase %s:" % case for case in init_states])

		new_state_check_optional = ""
		event_check_optional = ""
		event_funcs = ""
		new_state_var = ""
		
		if len(self.events):
			event_funcs = self.build_event_funcs()
			advance_func_proto = _ADVANCE_FUNC_PROTO_EVENT_BASED
			event_check_optional = _CHECK_EVENT % {
			    "event_enum" : self.event_enum,
			}
			new_state_var = _NEW_STATE_VAR % {
			    "state_enum" : self.state_enum,
			}
			transition_check = self._build_event_transition_checks()
			error_handlers = _EVENT_INVALID_FOR_STATE
		else:
			advance_func_proto = _ADVANCE_FUNC_PROTO_STATE_BASED
			new_state_check_optional = _CHECK_NEW_STATE % {
			    "state_enum" : self.state_enum,
			}
			transition_check = self._build_state_transition_checks()
			error_handlers = _BAD_TRANSITION

		if entry_preconds != "":
			error_handlers += _ENTRY_PRECOND_FAIL
		if exit_preconds != "":
			error_handlers += _EXIT_PRECOND_FAIL
		if event_preconds != "":
			error_handlers += _EVENT_PRECOND_FAIL
		error_handlers %= {
		    "state_enum_to_string_func" :
		        self.state_enum_to_string_func,
		    "event_enum_to_string_func" :
		        self.event_enum_to_string_func,
		}


		advance_func_proto %= {
		    "advance_func" : self.advance_func,
		    "state_enum" : self.state_enum,
		    "event_enum" : self.event_enum,
		    "struct_name" : self.struct_name,
		    "ctx" : advance_ctx_arg,
		}

		init_func_def %= {
		    "init_func" : self.init_func,
		    "state_enum" : self.state_enum,
		    "struct_name" : self.struct_name,
		    "initial_state" : init_states[0],
		    "init_state_cases" : init_state_cases,
		    "state_enum_to_string_func" :
		        self.state_enum_to_string_func,
		}

		print >> h, _C_SOURCE % {
		    "header_path" : header_path,
		    "self_promotion" : _SELF_PROMOTION,
		    "banner" : banner,
		    "struct_name" : self.struct_name,
		    "state_enum" : self.state_enum,
		    "init_func" : self.init_func,
		    "free_func" : self.free_func,
		    "advance_func" : self.advance_func,
		    "new_state_opt" : new_state_var,
		    "event_functions_optional" : event_funcs,
		    "event_check_optional" : event_check_optional,
		    "new_state_check_optional" : new_state_check_optional,
		    "state_enum_to_string_func" :
		        self.state_enum_to_string_func,
		    "current_state_func" : self.current_state_func,
		    "state_func_prototypes" : state_func_prototypes,
		    "event_func_prototypes" : event_func_prototypes,
		    "min_state_valid" : self.state_list[0].name,
		    "max_state_valid" : self.state_list[-1].name,
		    "enum_contents" : enum_contents,
		    "init_func_def" : init_func_def,
		    "transition_check" : transition_check,
		    "entry_preconds" : entry_preconds,
		    "exit_preconds" : exit_preconds,
		    "exit_funcs" : exit_funcs,
		    "entry_funcs" : entry_funcs,
		    "event_preconds" : event_preconds,
		    "event_callbacks" : event_callbacks,
		    "error_handlers" : error_handlers,
		    "advance_func_proto" : advance_func_proto,
		}

	def output_dot(self, h):
		# XXX pretty basic. Doesn't show preconditions, etc.
		# XXX should be a template
		print >> h, "digraph FSM {"
		print >> h, "	rankdir = LR;"
		print >> h, "	node [shape = doublecircle];",
		for state in self.state_list:
			if not state.initial:
				continue;
			print >> h, state.name,
		print >> h, "\n	node [shape = circle];",
		for state in self.state_list:
			if state.initial:
				continue;
			print >> h, state.name,
		print >> h, ""
		for arc in self.transitions:
			label = ""
			if self.transitions[arc] is not None:
				label = ' [ label = "%s" ]' % \
				    self.transitions[arc].name
			print >> h, "	%s%s;" % (arc, label)
		print >> h, "}"

class OrderedSet:
	"""Minimal, write-once ordered set"""
	def __init__(self, iv=[]):
		self.s = set(iv)
		self.v = list(iv)
	def add(self, a):
		if not a in self.s:
			self.s.add(a)
			self.v.append(a)
	def __getitem__(self, n):
		return self.v.__getitem__(n)
	def __iter__(self):
		return self.v.__iter__()
	def __len__(self):
		return self.v.__len__()
	def __repr__(self):
		return self.__class__.__name__ + "(" + repr(self.v) + ")"

class State:
	def __init__(self, name):
		self._name_check(name)
		self.name = name
		self.next_states = OrderedSet()
		self.pre_entry_funcs = OrderedSet()
		self.post_entry_funcs = OrderedSet()
		self.pre_exit_funcs = OrderedSet()
		self.post_exit_funcs = OrderedSet()
		self.initial = False

	def _name_check(self, name):
		if re.match('^[A-Za-z_][A-Za-z0-9_]*$', name) is None:
			raise ValueError, "Invalid name \"%s\"" % name
	def add_next_state(self, name):
		self._name_check(name)
		self.next_states.add(name)
	def add_pre_entry_func(self, name):
		self._name_check(name)
		self.pre_entry_funcs.add(name)
	def add_post_entry_func(self, name):
		self._name_check(name)
		self.post_entry_funcs.add(name)
	def add_pre_exit_func(self, name):
		self._name_check(name)
		self.pre_exit_funcs.add(name)
	def add_post_exit_func(self, name):
		self._name_check(name)
		self.post_exit_funcs.add(name)

class Event:
	def __init__(self, name):
		self._name_check(name)
		self.name = name
		self.next_states = {}
		self.pre_entry_funcs = OrderedSet()
		self.post_entry_funcs = OrderedSet()
		self.initial = False

	def _name_check(self, name):
		if re.match('^[A-Za-z_][A-Za-z0-9_]*$', name) is None:
			raise ValueError, "Invalid name \"%s\"" % name
	def add_next_state(self, current, next):
		self._name_check(current)
		self._name_check(next)
		if current in self.next_states and \
		   self.next_states[current] != next:
			raise ValueError, \
			    "transition from %s already set for event %s" % \
			    (current, self.name)
		self.next_states[current] = next
	def add_pre_entry_func(self, name):
		self._name_check(name)
		self.pre_entry_funcs.add(name)
	def add_post_entry_func(self, name):
		self._name_check(name)
		self.post_entry_funcs.add(name)

# -------------------------------------------------------------------------
# The following section contains the template strings and fragments that
# are emitted into the generated C source and header files
# -------------------------------------------------------------------------

_SELF_PROMOTION = """/*
 * Automatically generated using the cfsm FSM compiler:
 * http://www.mindrot.org/projects/cfsm/
 */"""

# -------------------------------------------------------------------------

_INIT_FUNC_MULTI = """/*
 * Allocate a new FSM and set its starting state to "initial_state".
 * Will return a pointer to the opaque FSM structure on success or 
 * NULL on failure. If "errbuf" is not NULL, upto "errlen" bytes of
 * error message will be copied into "errbuf" on failure.
 */
struct %(struct_name)s *%(init_func)s(enum %(state_enum)s initial_state,
    char *errbuf, size_t errlen);"""

# -------------------------------------------------------------------------

_INIT_FUNC_SINGLE = """/*
 * Allocate a new FSM and set its starting state to %(init_state)s
 * Will return a pointer to the opaque FSM structure on success or 
 * NULL on failure. If "errbuf" is not NULL, upto "errlen" bytes of
 * error message will be copied into "errbuf" on failure.
 */
struct %(struct_name)s *%(init_func)s(char *errbuf, size_t errlen);"""

# -------------------------------------------------------------------------

_ADVANCE_FUNC_COMMENT_STATE_BASED = \
"""/*
 * Attempt to advance to the state specified by "new_state".%(ctx)s
 * Will return 0 on success, -1 on failure. If "errbuf" is not NULL,
 * upto "errlen" bytes of error message will be copied into "errbuf" on
 * failure.
 */"""

_ADVANCE_FUNC_PROTO_STATE_BASED = """
int %(advance_func)s(struct %(struct_name)s *fsm, enum %(state_enum)s new_state,
    %(ctx)schar *errbuf, size_t errlen)"""

_ADVANCE_FUNC_COMMENT_EVENT_BASED = \
"""/*
 * Execute a pre-defined event on the FSM that may trigger a transition.%(ctx)s
 * Will return 0 on success or -1 on failure. If "errbuf" is not NULL,
 * upto "errlen" bytes of error message will be copied into "errbuf" on
 * failure.
 */"""

_ADVANCE_FUNC_PROTO_EVENT_BASED = """
int %(advance_func)s(struct %(struct_name)s *fsm, enum %(event_enum)s ev,
    %(ctx)schar *errbuf, size_t errlen)"""

_ADVANCE_FUNC_CTX_ARG = """void *ctx, """
_ADVANCE_FUNC_CTX_COMMENT = """
 * The "ctx" argument is a caller-specific context pointer that may be
 * used to pass additional state to precondition, event and transition
 * callback functions."""

# -------------------------------------------------------------------------

_EVENT_ENUM_DECL = """
/*
 * Events that may cause state transitions in the FSM
 */
enum %(event_enum)s {
%(event_enum_contents)s};
"""

_EVENT_FUNCS_DECL = """
/*
 * Convert from the %(event_enum)s enumeration to a string. Will return
 * NULL if the event is not known.
 */
const char *%(event_enum_to_string_func)s(enum %(event_enum)s);

/*
 * "Safe" version of %(event_enum_to_string_func)s. Will return the string
 * "[INVALID]" if the event is not known, so it can be used directly
 * in printf() statements, etc.
 */
const char *%(event_enum_to_string_func)s_safe(enum %(event_enum)s);
"""

# -------------------------------------------------------------------------

_C_HEADER="""%(banner)s%(self_promotion)s

#ifndef %(guard)s
#define %(guard)s

#include <sys/types.h>

/*
 * The valid states of the FSM
 */
enum %(state_enum)s {
%(enum_contents)s};
%(event_enum_optional)s
/*
 * The FSM object itself. This is intentionally opaque - all access must be
 * through this API
 */
struct %(struct_name)s;

%(init_func_proto_comments)s
/*
 * Free a FSM created with %(init_func)s()
 */
void %(free_func)s(struct %(struct_name)s *fsm);

%(advance_func_comment)s%(advance_func_proto)s;
%(event_funcs_optional)s
/*
 * Convert from the %(state_enum)s enumeration to a string. Will return
 * NULL if the state is not known.
 */
const char *%(state_enum_to_string_func)s(enum %(state_enum)s);

/*
 * "Safe" version of %(state_enum_to_string_func)s. Will return the string
 * "[INVALID]" if the state is not known, so it can be used directly
 * in printf() statements, etc.
 */
const char *%(state_enum_to_string_func)s_safe(enum %(state_enum)s);

/*
 * Returns the current state of the FSM.
 */
enum %(state_enum)s %(current_state_func)s(struct %(struct_name)s *fsm);

#endif /* %(guard)s */
"""

# -------------------------------------------------------------------------

_STATE_TRANS_FUNC_COMMENT = """
/* Prototypes for state transition functions */
"""
_STATE_PRECOND_FUNC_COMMENT = """
/* Prototypes for state precondition checks */
"""
_EVENT_TRANS_FUNC_COMMENT = """
/* Prototypes for event callback functions */
"""
_EVENT_PRECOND_FUNC_COMMENT = """
/* Prototypes for event precondition checks */
"""

_TRANS_FUNC_PROTO_START = "void %(func)s("
_TRANS_FUNC_PROTO_EVENT = "enum %(event_enum)s"
_TRANS_FUNC_PROTO_CURRENT = "enum %(state_enum)s"
_TRANS_FUNC_PROTO_NEW = "enum %(state_enum)s"
_TRANS_FUNC_PROTO_CTX = "void *"
_TRANS_FUNC_PROTO_NOARGS = "void"
_TRANS_FUNC_PROTO_END = ");\n"
_PRECOND_FUNC_PROTO_START = "int %(func)s("
_PRECOND_FUNC_PROTO_EVENT = "enum %(event_enum)s"
_PRECOND_FUNC_PROTO_CURRENT = "enum %(state_enum)s"
_PRECOND_FUNC_PROTO_NEW = "enum %(state_enum)s"
_PRECOND_FUNC_PROTO_CTX = "void *"
_PRECOND_FUNC_PROTO_NOARGS = "void"
_PRECOND_FUNC_PROTO_END = ");\n"

# -------------------------------------------------------------------------

_STATE_INIT_FUNC_MULTI = \
"""struct %(struct_name)s *
%(init_func)s(enum %(state_enum)s initial_state, char *errbuf, size_t errlen)
{
	struct %(struct_name)s *ret = NULL;

	switch (initial_state) {
%(init_state_cases)s
		break;
	default:
		if (errlen > 0 && errbuf != NULL) {
			snprintf(errbuf, errlen,
			    "State %%s (%%d) is not a valid start state",
			    %(state_enum_to_string_func)s_safe(initial_state),
			    initial_state);
		}
		return NULL;
	}
	if ((ret = calloc(1, sizeof(*ret))) == NULL) {
		if (errlen > 0 && errbuf != NULL)
			snprintf(errbuf, errlen, "Memory allocation failed");
		return NULL;
	}
	ret->current_state = initial_state;
	return ret;
}"""

# -------------------------------------------------------------------------

_STATE_INIT_FUNC_SINGLE = \
"""struct %(struct_name)s *
%(init_func)s(char *errbuf, size_t errlen)
{
	struct %(struct_name)s *ret = NULL;

	if ((ret = calloc(1, sizeof(*ret))) == NULL) {
		if (errlen > 0 && errbuf != NULL)
			snprintf(errbuf, errlen, "Memory allocation failed");
		return NULL;
	}
	ret->current_state = %(initial_state)s;
	return ret;
}"""

# -------------------------------------------------------------------------

_STATE_CALL_SWITCH_START = \
"""
	/* %(which)s %(what)s */
	switch (%(var)s) {
"""

_STATE_CALL_SWITCH_CASE = \
"""	case %(state)s:
"""

_STATE_CALL_SWITCH_FINISH = \
"""	default:
		break; /* Hush compiler warnings */
	}
"""

_EVENT_CALL_SWITCH_START = \
"""
	/* %(what)s */
	switch (ev) {
"""

_EVENT_CALL_SWITCH_CASE = \
"""	case %(event)s:
"""

_EVENT_CALL_SWITCH_FINISH = \
"""	default:
		break; /* Hush compiler warnings */
	}
"""

# -------------------------------------------------------------------------

_PRECOND_FUNC_CALLSIG_EVENT = "ev"
_PRECOND_FUNC_CALLSIG_CURRENT = "fsm->current_state"
_PRECOND_FUNC_CALLSIG_NEW = "new_state"
_PRECOND_FUNC_CALLSIG_CTX = "ctx"
_PRECOND_FUNC_CALLSIG_START = "\t\tif (%(func)s("
_PRECOND_FUNC_CALLSIG_END = ") != 0)\n\t\t\tgoto %(which)s_precond_fail;\n"
_TRANS_FUNC_CALLSIG_EVENT = "ev"
_TRANS_FUNC_CALLSIG_CURRENT = "fsm->current_state"
_TRANS_FUNC_CALLSIG_OLD = "old_state"
_TRANS_FUNC_CALLSIG_NEW = "new_state"
_TRANS_FUNC_CALLSIG_CTX = "ctx"
_TRANS_FUNC_CALLSIG_START = "\t\t%(func)s("
_TRANS_FUNC_CALLSIG_END = ");\n"

# -------------------------------------------------------------------------

_ENTRY_PRECOND_FAIL = \
""" entry_precond_fail:
	if (errlen > 0 && errbuf != NULL) {
		snprintf(errbuf, errlen,
		    "State %%s entry precondition not satisfied",
		    %(state_enum_to_string_func)s_safe(new_state));
	}
	return -1;
"""

_EXIT_PRECOND_FAIL = \
""" exit_precond_fail:
	if (errlen > 0 && errbuf != NULL) {
		snprintf(errbuf, errlen,
		    "State %%s exit precondition not satisfied",
		    %(state_enum_to_string_func)s_safe(fsm->current_state));
	}
	return -1;
"""

_EVENT_PRECOND_FAIL = \
""" event_precond_fail:
	if (errlen > 0 && errbuf != NULL) {
		snprintf(errbuf, errlen,
		    "Event %%s entry precondition not satisfied",
		    %(event_enum_to_string_func)s_safe(ev));
	}
	return -1;
"""

_EVENT_INVALID_FOR_STATE = \
""" bad_event:
	if (errlen > 0 && errbuf != NULL) {
		snprintf(errbuf, errlen,
		    "Invalid event %%s in state %%s",
		    %(event_enum_to_string_func)s_safe(ev),
		    %(state_enum_to_string_func)s_safe(fsm->current_state));
	}
	return -1;
"""

_BAD_TRANSITION = \
""" bad_transition:
	if (errlen > 0 && errbuf != NULL) {
		snprintf(errbuf, errlen,
		    "Illegal state transition attempted: %%s -> %%s",
		    %(state_enum_to_string_func)s_safe(fsm->current_state),
		    %(state_enum_to_string_func)s_safe(new_state));
	}
	return -1;
"""

_CHECK_NEW_STATE = \
"""	if (_is_%(state_enum)s_valid(new_state) != 0) {
		if (errlen > 0 && errbuf != NULL) {
			snprintf(errbuf, errlen, "Invalid new_state (%%d)",
			    new_state);
		}
		return -1;
	}
"""

_CHECK_EVENT = \
"""	if (_is_%(event_enum)s_valid(ev) != 0) {
		if (errlen > 0 && errbuf != NULL)
			snprintf(errbuf, errlen, "Invalid event (%%d)", ev);
		return -1;
	}
"""

# -------------------------------------------------------------------------

_EVENT_FUNCTIONS="""
static int
_is_%(event_enum)s_valid(enum %(event_enum)s n)
{
	if (!(n >= %(min_event_valid)s && n <= %(max_event_valid)s))
		return -1;
	return 0;
}

const char *
%(event_enum_to_string_func)s(enum %(event_enum)s n)
{
	const char *event_names[] = {
%(enum_contents)s	};

	if (_is_%(event_enum)s_valid(n) != 0)
		return NULL;
	return event_names[n];
}

const char *
%(event_enum_to_string_func)s_safe(enum %(event_enum)s n)
{
	const char *r = %(event_enum_to_string_func)s(n);

	return r == NULL ? "[INVALID]" : r;
}
"""

# -------------------------------------------------------------------------

_NEW_STATE_VAR = "	enum %(state_enum)s new_state;\n"

_C_SOURCE="""%(banner)s%(self_promotion)s

#include <sys/types.h>

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "%(header_path)s"

/* Private view of opaque FSM structure */
struct %(struct_name)s {
	enum %(state_enum)s current_state;
};
%(state_func_prototypes)s%(event_func_prototypes)s
static int
_is_%(state_enum)s_valid(enum %(state_enum)s n)
{
	if (!(n >= %(min_state_valid)s && n <= %(max_state_valid)s))
		return -1;
	return 0;
}

const char *
%(state_enum_to_string_func)s(enum %(state_enum)s n)
{
	const char *state_names[] = {
%(enum_contents)s	};

	if (_is_%(state_enum)s_valid(n) != 0)
		return NULL;
	return state_names[n];
}

const char *
%(state_enum_to_string_func)s_safe(enum %(state_enum)s n)
{
	const char *r = %(state_enum_to_string_func)s(n);

	return r == NULL ? "[INVALID]" : r;
}

%(event_functions_optional)s
%(init_func_def)s

void
%(free_func)s(struct %(struct_name)s *fsm)
{
	memset(fsm, '\\0', sizeof(fsm));
	free(fsm);
}

enum %(state_enum)s
%(current_state_func)s(struct %(struct_name)s *fsm)
{
	return fsm->current_state;
}
%(advance_func_proto)s
{
	enum %(state_enum)s old_state;
%(new_state_opt)s
	/* Sanity check states */
	if (_is_%(state_enum)s_valid(fsm->current_state) != 0) {
		if (errlen > 0 && errbuf != NULL) {
			snprintf(errbuf, errlen, "Invalid current_state (%%d)",
			    fsm->current_state);
		}
		return -1;
	}
%(new_state_check_optional)s%(event_check_optional)s
%(transition_check)s
%(event_preconds)s%(exit_preconds)s%(entry_preconds)s%(event_callbacks)s%(exit_funcs)s
	/* Switch state now */
	old_state = fsm->current_state;
	fsm->current_state = new_state;
%(entry_funcs)s
	return 0;

%(error_handlers)s}
"""

# -------------------------------------------------------------------------

if __name__ == '__main__':
	main()
